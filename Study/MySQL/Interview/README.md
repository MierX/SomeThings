# 什么是聚集索引和非聚集索引？

> 简单来说，聚集索引就是基于主键创建的索引，除了主键索引以外的其他索引，称为非聚集索引，也叫做二级索引
>
> > 由于在 InnoDB 引擎里面，一张表的数据对应的物理文件本身就是按照 B+树来组织的一种索引结构，而聚集索引就是按照每张表的主键来构建一颗 B+树，然后叶子节点里面存储了这个表的每一行数据记录
>
> > 所以基于 InnoDB 这样的特性，聚集索引并不仅仅是一种索引类型，还代表着一 种数据的存储方式
>
> > 同时也意味着每个表里面必须要有一个主键，如果没有主键，InnoDB 会默认选择或者添加一个隐藏列作为主键索引来存储这个表的数据行。一般情况是建议使 用自增 id 作为主键，这样的话 id 本身具有连续性使得对应的数据也会按照顺序存储在磁盘上，写入性能和检索性能都很高。否则，如果使用 uuid 这种随机 id，那么在频繁插入数据的时候，就会导致随机磁盘 IO，从而导致性能较低。需要注意的是，InnoDB 里面只能存在一个聚集索引，原因很简单，如果存在多个聚集索引，那么意味着这个表里面的数据存在多个副本，造成磁盘空间的浪费，以及数据维护的困难
>
> > 由于在 InnoDB 里面，主键索引表示的是一种数据存储结构，所以如果是基于非聚集索引来查询一条完整的记录，最终还是需要访问主键索引来检索

# 请简单说一下MySQL索引的优点和缺点

> 索引，是一种能够帮助MySQL高效地从磁盘上检索数据的一种数据结构，在MySQL中的InnoDB引擎中，采用了B+树的结构来实现索引和数据的存储
>
> 索引的优点主要有：
> > 通过B+树的结构来存储数据，可以大大减少数据检索时的磁盘IO次数，从而提升数据查询的性能
>
> > 通过唯一索引约束，可以保证数据表中每一行数据的唯一性
>
> 索引的缺点主要有：
> > 数据的增加、修改、删除，需要涉及到索引的维护，当数据量较大的情况下，索引的维护会带来较大的性能开销
>
> > 一个表中允许存在一个聚簇索引和多个非聚簇索引，但是索引数不能创建太多，否则造成索引的维护成本过高
>
> > 创建索引的时候，需要考虑到索引字段值的分散性，如果字段的重复数据过多，创建索引反而会带来性能降低

# 请简单说一下MySQL的事务隔离级别

> 事务隔离界别是为了解决多个并行事务竞争导致的数据安全问题的一种规范，多个事务竞争可能会产生三种情况：
> > 脏读：假设有两个事务T1、T2同时在执行，T1有可能会读取到T2未提交的数据，但是未提交的T2可能会回滚，也就导致了T1读取到的最终不一定存在的数据产生了脏读
>
> > 不可重复读：假设有两个事务T1、T2同时执行，T1在不同的时刻读取同一行数据的结构可能不一样，从而导致不可能重复读的问题
>
> > 幻读：假设有两个事务T1、T2同时执行，T1执行范围查询或者范围修改的过程中，T2插入一条属于T1范围内的数据并且提交了，这时候在T1查询发现多出来了一条数据，或者在T1事务发现这条数据没有被修改，产生了幻读
>
> 而以上三种现象在实际应用中，可能有些场景不能接受某种现象的存在，所以SQL标准中定义了四种隔离级别，分别是：
> > 读未提交：在这种隔离级别下，可能会产生脏读、不可重复读、幻读
>
> > 读已提交（RC）：在这种隔离级别下，可能会产生不可重复读和幻读
>
> > 可重复读（RR）：在这种隔离级别下，可能会产生幻读
>
> > 串行化：在这种隔离级别下，多个并行事务串行化执行，不会产生安全性问题
>
> 以上四种隔离级别里，只有串行化解决了全部的问题，但也意味着这种隔离级别的性能最低
>
> 在MySQL里面，InnoDB引擎默认的隔离级别是RR（可重复读），因为它需要保证事务ACID特性中的隔离性特征

# MySQL为什么使用B+Tree作为索引结构？

> 常规的数据库存储引擎，一般都是采用B树或者B+树来实现索引的存储：
> > 因为B树是一种多路平衡树，用这种存储结构来存储大量数据，它的整个高度会相比二叉树来说矮很多，而对于数据库来说，所有的数据必然都是存储在磁盘上的，而磁盘IO的效率实际上是很低的，特别是在随即磁盘IO的情况下效率更低，所以树的高度能够决定磁盘IO的次数，磁盘IO次数越少，对于性能的提升就越大，这也是为什么采用B树作为索引存储结构的原因
>
> 但是在MySQL的InnoDB存储引擎里面，它用了一种增强的B树结构，也就是B+树来作为索引和数据的存储结构，相比较于B树结构，B+树做了几个方面的优化：
> > B+树的所有数据都存储在叶子节点，非叶子节点只存储索引
>
> > 叶子节点中的数据使用双向链表的方式进行关联
>
> B+树非叶子节点不存储数据，所以每一层能够存储的索引数量会增加，意味着B+树在层高相同的情况下存储的数据量要比B树要多，使得磁盘IO次数更少
>
> 在MySQL里面，范围查询是一个比较常用的操作，而B+树所有的存储在叶子节点的数据使用了双向链表来关联，所以在查询的时候只需要查两个节点进行遍历就行，而B树需要获取所有节点，所以B+树在范围查询上效率更高
>
> 在数据检索方面，由于所有的数据都存储在叶子节点，所以B+树的IO次数会更加稳定一些，因为叶子节点存储所有数据，所以B+树的全局扫描能力更强一些，因为它只需要扫描叶子节点，但是B树需要遍历整个树，另外，基于B+树这样一种结构，如果采用自增的整形数据作为主键，还能更好的避免增加数据的时候，带来叶子节点分裂导致的大量运算的问题
>
> 总的来说，技术方案的选型更多的是去解决当下场景下的特定问题，并不一定是说B+树就是最好的选择，就像MongoDB里面采用了B树结构，本质上说，其实是关系型数据库和非关系型数据库的差异

# 对MySQL性能优化有哪些方法？

> MySQL的性能优化可以分为四个部分：
> > 硬件和操作系统层面的优化：
> > > 从硬件层面来说，影响MySQL性能的因素有CPU、可用内存大小、磁盘读写速度、网络带宽
> >
> > > 从操作系统层面来说，应用文件句柄数、操作系统网络的配置都会影响到MySQL的性能
> >
> > > 这部分的优化一般由DBA或者运维工程师来完成，在硬件基础资源的优化中，我们更应该重点关注服务器本身承载的体谅，然后提出合理的指标要求，避免出现资源浪费
> >
> > 架构设计层面的优化：
> > > MySQL是一个磁盘IO访问量非常频繁的关系型数据库，在高并发和高性能的场景中，MySQL数据库必然会承受巨大的并发压力，而此时我们的优化方式可以有：
> > > > 搭建MySQL主从集群，单个MySQL服务容易单点故障，一旦服务器宕机，将会导致依赖MySQL数据库的应用全部无法响应，主从集群或者主主集群可以保证服务的高可用性
> > >
> > > > 读写分离设计，在读多写少的场景中，通过读写分离的方案，可以避免读写冲突导致的性能影响
> > >
> > > > 引入分库分表机制，通过分库可以降低单个服务器节点的IO压力，通过分表的方式可以降低单表数据量，从而提升SQL查询的效率
> > >
> > > > 针对热点数据，可以引入更为高效的分布式数据库，比如Redis、MongoDB等，它们可以很好的缓解MySQL的访问压力，同时还能提升数据检索性能
> >
> > MySQL程序配置优化：
> > > MySQL是一个经过验证的生产级别的成熟数据库，对于MySQL数据库本身的优化，一般都是通过MySQL中的配置文件`my.cnf`来完成的，比如：
> > > > MySQL5.7版本默认的最大连接数是151个，这个值可以在文件中修改
> > >
> > > > binlog日志，默认是不开启的
> > >
> > > > 缓存池bufferpoll的默认大小配置等
> > >
> > > 由于这些配置一般都和用户安装的硬件环境以及使用场景有关系，因此这些配置官方只会提供一个默认值，具体情况还得由使用者来修改，关于配置项的修改，需要关注两个方面：
> > > > 配置的作用域分为会话级别和全局
> > >
> > > > 是否支持热加载
> > >
> > >因此，针对这两个点，我们需要注意的是：
> > > > 全局参数的设定对于已经存在的会话无法生效
> > >
> > > > 全局类的统一配置建议配置在默认配置文件中，否则重启服务会导致配置失效
> >
> > SQL优化又能分为三步：
> > > 慢SQL的定位和排查：我们可以通过慢查询日志和慢查询日志分析工具得到有问题的SQL列表
> >
> > > 执行计划分析：针对慢SQL，我们可以使用关键字explain来查看当前sql的执行计划.可以重点关注type key rows filterd等字段 ，从而定位该SQL执行慢的根本原因，再有的放矢的进行优化
> >
> > > 使用show profile工具：Show Profile是MySQL提供的可以用来分析当前会话中，SQL语句资源消耗情况的工具，可用于SQL调优的测量。在当前会话中.默认情况下处于show profile是关闭状态，打开之后保存最近15次的运行结果，针对运行慢的SQL，通过profile工具进行详细分析.可以得到SQL执行过程中所有的资源开销情况

# 什么是事务？有什么特性？

> 事务是一系列的数据库操作，是数据库应用的基本逻辑单位
>
> 事务特性有：
>
> > 原子性：即不可分割性，事务要么全部被执行，要么全部不执行
>
> > 一致性（可串性）：事务的执行使得数据库从一种正确状态转换成另一种正确状态
>
> > 隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其它事务
>
> > 持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其它故障，事务的处理结果也会得到保存

# 什么是锁？

> 数据库是一个多用户使用的共享资源，当多个用户并发地存取数据时，在数据库中会产生多个事务同时存取同一数据的情况，若对并发操作不加控制，就可能会读取和存储不正确的数据，破坏数据库的一致性
>
> 加锁是实现数据库并发控制的一个非常重要的技术，当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁，加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作
>
> 基本锁类型：锁包括行级锁和表级锁

# 索引的作用？有什么优缺点？

> 索引是一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。类似现实生活中的书的目录，不需要查询整本书的内容就可以找到想要的数据
>
> 索引可以是唯一的，创建索引允许指定单个列或者是多个列
>
> 缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小

# 请写出数据类型（int char varchar datetime text）的意思，请问varchar和char有什么区别？

> int：整型字段
>
> char：定长型字符串字段
>
> varchar：变长型字符串字段
>
> datetime：日期时间型字段
>
> text：文本型字段
>
> varchar与char的区别：
>
> > char是固定长度的字符类型，分配多少空间便占用多少空间，即使字段为空，也会占用空间，所以比较浪费资源
>
> > varchar是可变长度的字符类型，内容有多大就占用多大的空间，能有效节省空间。由于varchar类型是可变的，所以在数据长度改变时，服务器要进行额外的操作，所以效率比char类型低

# MyISAM和InnoDB的基本区别？索引结构如何实现？

> MyISAM类型不支持事务，表锁，易产生碎片，要经常优化，但是读写速度较快，适合用于频繁查询的应用
>
> InnoDB类型支持事务，行锁，有崩溃恢复能力，读写速度比MyISAM慢，适合于插入和更新操作比较多的应用，空间占用大，不支持全文索引等
>
> 创建索引：``alert table tableName add index indexName(`fieldName`)``
